\textbf{Hierarchical planning} are planning strategies that use different \textbf{levels of abstraction} to create a plan. This algorithm can design a plan following two
different ways, which are:
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{-}
    \item Assigning \textbf{critical values} to any possible precondition.
    \item Deviding the actions of a plan into \textbf{atomic operators} and \textbf{macro operators}\footnote{All operators are again defined by preconditions and effects, as usual.}.
\end{itemize}

Popular hierarchical planning algorithms are:
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{-}
    \item STRIPS-like.
    \item Partial Order Planning-like.
\end{itemize} \vspace{3.5pt}

\textbf{ABSTRIPS} \\
Planners who enhance the STRIPS-like definition of actions use \textbf{criticality values} associated to each possible preconditions; values are proportional to the complexity 
of the actions achievement. \vspace{3.5pt}

The planning algorithm proceeds at different levels of abstraction spaces. At each level, preconditions related to a lower criticality value are ignored. \vspace{3.5pt}

Given some hints, it's possible to summarize some steps that describe the real behavior of ABSTRIPS:
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{}
    \item $1^{st}$ A \textbf{threshold} value is fixed; generally, it starts from the value associated with the most complex action to achieve.
    \item $2^{nd}$ All the preconditions whose \textbf{criticality value} is less than the threshold are considered true, ignored somehow.
    \item $3^{rd}$ STRIPS finds a plan that meets all the preconditions whose criticality value is greater or equal to the threshold chosen previously.
    \item $4^{th}$ It then uses the plan obtained as a guide and it \textbf{decreases} the value of the threshold.
    \item $5^{th}$ It extends the plan with operators or actions having a criticality value that satisfies the current threshold.
    \item $6^{th}$ It decreases the value of the threshold until all the preconditions have been considered.
\end{itemize}

Let's see an example for better understanding.
\begin{example}
    i.e. Sussman anomaly. \vspace{3.5pt} 

    Given an initial state \vspace{7pt}
    \begin{center}
        \begin{tabular}{l}
            \textbf{Initial state} \\
            $ontable(a), ontable(b)$ \\
            $clear(b), clear(c)$ \\
            $handempty, on(c,a)$ 
        \end{tabular}
    \end{center} \vspace{3.5pt}
    define a plan that reaches the goal state \vspace{7pt}
    \begin{center}
        \begin{tabular}{l}
            \textbf{Goal state} \\
            $on(b,c) \land on(c,a)$
        \end{tabular}
    \end{center}
    The executable actions are: \vspace{7pt}
    \begin{center}
        \begin{tabular}{l}
            \textbf{Putdown(X)} \\
            Precond: $holding(X)$ \\
            Effect: $handempty, clear(X), ontable(X), \neg \text{Precond}$
        \end{tabular} \vspace{7pt}

        \begin{tabular}{l}
            \textbf{Stack(X,Y)} \\
            Precond: $holding(X), clear(Y)$ \\
            Effect: $handempty, on(X,Y), clear(X), \neg \text{Precond}$\footnote{To save space, we did not list every precondition that was denied by the action.}
        \end{tabular} \vspace{7pt}

        \begin{tabular}{l}
            \textbf{Pickup(X)} \\
            Precond: $handempty, clear(X), ontable(X)$ \\
            Effect: $holding(X), \neg \text{Precond}$
        \end{tabular} \vspace{7pt}

        \begin{tabular}{l}
            \textbf{Unstack(X,Y)} \\
            Precond: $handempty, on(X,Y), clear(Y)$ \\
            Effect: $holding(X), clear(Y), \neg \text{Precond}$
        \end{tabular} \vspace{7pt}
    \end{center} \vspace{3.5pt}

    $1^{st}$ step:
    \begin{itemize}[nosep]
        \renewcommand{\labelitemi}{-}
        \item Specify a hierarchical order according to the criticality values associated to the predicates.
    \end{itemize} \vspace{7pt}

    \begin{center}
        \begin{tabular}{l}
            \textbf{Predicates} \\
            $on(...)$ $\textbf{(3)}$ \\ 
            $ontable(...), clear(...), holding(...)$ $\textbf{(2)}$ \\
            $handempty$ $\textbf{(1)}$ \\
        \end{tabular}
    \end{center} \vspace{3.5pt}

    $2^{st}$ step:
    \begin{itemize}[nosep]
        \renewcommand{\labelitemi}{-}
        \item Define the first level of abstraction considering only the preconditions with criticality value equal to 3.
        \item Determine which action matches the preconditions considered.
        \item Add to the plan the action to meet the current precondition.
    \end{itemize} \vspace{7pt}

    Since the first precondition to meet is $on(c, b)$ the only action capable is $stack(c, b)$. All the preconditions of $stack(c, b)$ are less critical than the current threshold, 
    therefore they are considered true. \vspace{3.5pt}
    
    \begin{center}
        \begin{tabular}{ll}
            \textbf{State} & \textbf{Goal stack} \\
            $handempty$ & $on(a, c)$ \\
            $\textbf{on(c, b)}, on(c, a)$ & $on(c, b) \land on(a, c)$ \\
            $clear(b), clear(c)$ & \\
            $ontable(a), ontable(b)$ &
        \end{tabular}
    \end{center} \vspace{3.5pt}

    The actions $stack(a, c)$ is added following the same process for $stack(c, b)$. The complete plan at level 1 is: $\langle 1.stack(c, b), 2.stack(a, c) \rangle$ \vspace{3.5pt}

    $3^{st}$ step:
    \begin{itemize}[nosep]
        \renewcommand{\labelitemi}{-}
        \item Define the second level of abstraction considering only the preconditions with criticality value equal to 2.
        \item Restart from the initial state and insert in the goal stack the initial goals, the action computed at level 1 and their precondtions.
    \end{itemize} \vspace{3.5pt}

    \begin{center}
        \begin{tabular}{l}
            \textbf{Goal stack} \\
            $holding(c)$ \\
            $clear(b)$ \\
            $holding(c) \land clear(b)$\\
            $\textbf{stack(c, b)}$ \\
            $holding(a)$ \\
            $clear(c)$ \\
            $holding(a) \land clear(c)$ \\
            $\textbf{stack(a, c)}$ \\
            $on(c, b) \land on(a, c)$
        \end{tabular}
    \end{center} \vspace{3.5pt}

    The condition $holding(c)$ is satisfiable with the action $unstack(c, X)$ and the stack becomes: \vspace{3.5pt}

    \begin{center}
        \begin{tabular}{l}
            \textbf{Goal stack} \\
            $clear(c)$ \\
            $on(c, X)$ \\
            $clear(c) \land on(c, X)$ \\
            $\textbf{unstack(c, X)}$ \\
            $holding(c)$ \\
            $clear(b)$ \\
            $holding(c) \land clear(b)$\\
            $\textbf{stack(c, b)}$ \\
            $holding(a)$ \\
            $clear(c)$ \\
            $holding(a) \land clear(c)$ \\
            $\textbf{stack(a, c)}$ \\
            $on(c, b) \land on(a, c)$
        \end{tabular}
    \end{center} \vspace{3.5pt}

    The preconditions of $unstack(c, X)$ are all met in the initial state by the substitution $X/a$. Executing the action $unstack(c, a)$ the initial state results: \vspace{3.5pt}

    \begin{center}
        \begin{tabular}{ll}
            \textbf{State} & \textbf{Goal stack} \\
            $clear(b)$ & $clear(b)$ \\
            $clear(a)$ &  $holding(c) \land clear(b)$ \\
            $ontable(a)$ & $\textbf{stack(c, b)}$ \\
            $ontable(b)$ & $holding(a)$ \\
            $handempty$ & $clear(c)$ \\
            $holding(c)$ & $holding(a) \land clear(c)$ \\
            & $\textbf{stack(a, c)}$ \\
            & $on(c, b) \land on(a, c)$
        \end{tabular}
    \end{center} \vspace{3.5pt}

    The complete plan at level 2 is: $\langle unstack(c, a) \land stack(c, b) \land pickup(a) \land stack(a, c) \rangle$ \vspace{3.5pt}

    $4^{st}$ step:
    \begin{itemize}[nosep]
        \renewcommand{\labelitemi}{-}
        \item Define the third level of abstraction considering only the preconditions with criticality value equal to 1.
        \item Restart from the initial state and insert in the goal stack the initial goals, the action computed at level 2 and their precondtions.
    \end{itemize} \vspace{3.5pt}

    \begin{center}
        \begin{tabular}{ll}
            \textbf{Goal stack} \\
            $handempty$ \\
            $clear(c)$ \\
            $on(c, a)$ \\
            $clear(c) \land on(c, a) \land handempty$ \\
            $\textbf{unstack(c, a)}$ \\
            $holding(c)$ \\
            $clear(b)$ \\
            $holding(c) \land clear(b)$\\
            $\textbf{stack(c, b)}$ \\
            $holding(a)$ \\
            $clear(c)$ \\
            $holding(a) \land clear(c)$ \\
            $\textbf{stack(a, c)}$ \\
            $on(c, b) \land on(a, c)$
        \end{tabular}
    \end{center} \vspace{3.5pt}

    Only the precondition $handempty$ still needs to be considered. The search for a solution to level 3 in this case is simply a check: the solution at level 2 is also 
    correct for level 3 and the search stops.
\end{example}

\textbf{Macro-operators} \\
This version of hierarchical planning uses two types of operators:
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{-}
    \item \textbf{Atomic operators}. \\ Atomic operators represent elementary actions that can be directly executed by an agent.
    \item \textbf{Macro operators}. \\ Macro operators represent a set of general actions that can be decomposed into \textbf{atomic operators}.
\end{itemize}

Every macro operator before its execution must be decomposed in any single action that makes it. Usually, its decomposition can be done by \textbf{precompiled decomposition} or 
by a \textbf{plan}. \vspace{3.5pt}

Precompiled decomposition occurs as follows: the description of the macro operator is divided into the basic operators to be executed at run-time.
\begin{example}
    i.e. Cook world. \vspace{3.5pt}

    Given the action  \vspace{7pt}

    \begin{center}
        \begin{tabular}{l}
            \textbf{Cook(X)} \\
            Precond: $have(X), have(pot), have(salt), in(water, salt)$ \\
            Effect: $cooked(X)$
        \end{tabular}
    \end{center} \vspace{3.5pt}

    decomposed it in its basic operators. \vspace{7pt}

    \begin{center}
        \begin{tabular}{l}
            \textbf{Decomposition} \\
            $S_1: boil(water)$, \\
            $S_2: put(salt, water)$, \\
            $S_3: put(X, pot)$, \\
            $S_4: boilinWater(X)$ \\
        \end{tabular}
    \end{center} \vspace{3.5pt}

    the ordering constraint is: $\langle S_1 < S_2, S_2 < S_3, S_2 < S_4, S_3 < S_4 \rangle$.
\end{example}

Instead the \textbf{decomposition} by a \textbf{plan} is performed through a low level search for summarizing the atomic actions that composed the macro action. The planning strategy can be 
either linear or non-linear, even though generally is preferred the second one, like Partial Ordering Planning. A hierarchical non-linear algorithm at each step can choose
one of the following behaviors:
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{-}
    \item \textbf{Reach an open goal with a operator}; we mean the preconditions defined above the actions.
    \item \textbf{Expand a macro step of the plan}; this means taking a macro action already in the plan and replacing it with its more detailed sequence of actions, so its decomposition.
\end{itemize} 

To ensure the decomposition is safe, some properties must be guaranteed. If the macro action $A$ has the effect $X$ and is expanded with the plan $P$:
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{-}
    \item $X$ must be the effect of at least one of the actions in which $A$ is decomposed and it should be protected until the end of the plan $P$.
    \item Each precondition of the actions in $P$ must be guaranteed by the previous actions in $P$ or it must be a precondition of $A$.
    \item The $P$ actions must not threat any causal link when $P$ is substituted for $A$ in the plan.
\end{itemize}

Only under these conditions you can replace the macro action $A$ with the plan $P$. When replacing $A$ with $P$, the orderings and casual links should be added.
\begin{itemize}[nosep]
    \renewcommand{\labelitemi}{-}
    \item \textbf{Orderings}
    \begin{itemize}[nosep]
        \renewcommand{\labelitemii}{-}
        \item For each $B$ such that $\langle B < A \rangle$ then $\langle B < first(P) \rangle$ must be imposed\footnote{With $first(P)$, we mean the first action of the decomposition.}.
        \item For each $B$ such that $\langle A < B \rangle$ then $\langle last(P) < B \rangle$ must be imposed\footnote{With $last(P)$, we mean the last action of the decomposition.}.
    \end{itemize}
    \item \textbf{Casual link}
    \begin{itemize}[nosep]
        \renewcommand{\labelitemii}{-}
        \item If $\langle S, C, A \rangle$ is a causal link in the initial plan, then it must be replaced by a set of causal links $\langle S, C, S_i \rangle$ where $S_i$ are the actions of $P$ that have $C$ as a precondition.
        \item If $\langle A, C, S \rangle$ is a causal link in the initial plan, then it must be replaced by a set of causal links $\langle S_i, C, S \rangle$ where $S_i$ are the actions of $P$ that have $C$ as a effect.
    \end{itemize}
\end{itemize} 